以下是一个简单的C语言程序，使用Pthreads库和信号量来实现生产者-消费者问题。在这个问题中，生产者线程将项目放入一个有界缓冲区，而消费者线程则从中取出项目。信号量用于同步对缓冲区的访问。
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#define BUFFER_SIZE 10
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
sem_t empty, full, mutex;
void *producer(void *param) {
    int item;
    while (1) {
        item = rand() % 100; // Generate a random item
        sem_wait(&empty); // Wait for an empty slot
        sem_wait(&mutex); // Enter critical section
        buffer[in] = item; // Add item to buffer
        in = (in + 1) % BUFFER_SIZE; // Update in index
        sem_post(&mutex); // Leave critical section
        sem_post(&full); // Signal that the buffer is full
        sleep(rand() % 3); // Sleep for a random time
    }
}
void *consumer(void *param) {
    int item;
    while (1) {
        sem_wait(&full); // Wait for a full slot
        sem_wait(&mutex); // Enter critical section
        item = buffer[out]; // Remove item from buffer
        out = (out + 1) % BUFFER_SIZE; // Update out index
        sem_post(&mutex); // Leave critical section
        sem_post(&empty); // Signal that the buffer is empty
        printf("Consumed item: %d\n", item);
        sleep(rand() % 3); // Sleep for a random time
    }
}
int main() {
    pthread_t producer_thread, consumer_thread;
    srand(time(NULL)); // Initialize random seed
    // Initialize semaphores
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);
    sem_init(&mutex, 0, 1);
    // Create producer and consumer threads
    pthread_create(&producer_thread, NULL, producer, NULL);
    pthread_create(&consumer_thread, NULL, consumer, NULL);
    // Wait for threads to finish
    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);
    // Destroy semaphores
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);
    return 0;
}
```
在这个程序中，我们定义了一个有界缓冲区`buffer`，并初始化了三个信号量`empty`、`full`和`mutex`。`empty`信号量表示缓冲区中的空槽数量，初始为缓冲区大小。`full`信号量表示缓冲区中的满槽数量，初始为0。`mutex`信号量用于保护对缓冲区的访问，确保互斥。
生产者线程在生成一个随机项目后，会等待`empty`信号量变为非零（表示有空槽），然后进入临界区，将项目放入缓冲区，并更新`in`索引。完成后，生产者会释放`full`信号量，表示缓冲区中有新的满槽。
消费者线程会等待`full`信号量变为非零（表示有满槽），然后进入临界区，从缓冲区中取出一个项目，并更新`out`索引。完成后，消费者会释放`empty`信号量，表示缓冲区中有新的空槽。
在`main`函数中，我们创建了生产者和消费者线程，并等待它们完成。最后，我们销毁了所有信号量。
请注意，这个程序中的生产者和消费者线程会无限循环地执行，生成和消费随机数。在实际应用中，您可能需要添加条件来终止线程，例如使用一个全局标志来指示何时停止生产或消费。
