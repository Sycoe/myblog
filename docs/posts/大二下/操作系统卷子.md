## 选择题

### 操作系统概念

- 内核态执行指令：I/O指令 
- 进程状态转换：
  - 从“运行”到“就绪”：出现比该进程优先级更高的进程 
- 动态重定位时机：程序运行时 
- 时间片长度与响应时间：进程数越少，响应时间越小 

### 多线程与调度

- 线程共享资源：进程P中打开的文件 
- 多线程模型：1对多模型 
- 调度算法防止饥饿：先来先服务、时间片轮转 

### 内存管理

- 抖动处理：撤销部分进程 
- 外部中断事件：除数为0 
- 文件最大长度计算：1057KB 

### 页面置换与死锁

- LRU算法淘汰页：页号4
- 死锁的最小K值：4
- 信号量计算：已分配资源数1，等待资源数2 

## 填空题

1. 死锁产生的四个必要条件：互斥使用、非剥夺、占有且等待、循环依赖
2. 进程大小72766B，页面大小2KB，内部碎片大小为1182B，逻辑地址2471的页号为1，页内偏移地址为423
3. 进程间通信方式：共享内存和消息传递队列
4. 操作系统程序状态：内核态，用户程序状态：用户态，通过系统调用请求操作系统服务
5. 两种I/O方法：同步I/O和异步I/O
6. 文件访问方法：顺序访问和随机访问
7. 临界区问题解决：互斥、进步和有限等待
8. CPU调度准则：CPU利用率、吞吐量、周转时间、等待时间、响应时间
9. 页面置换类型：全局置换和局部置换
10. 磁盘平均I/O时间：寻道时间、旋转延迟、数据传输时间

## 简答题

1. 使用系统调用创建子进程并执行新功能的流程
2. 程序局部性原理
3. 内部碎片和外部碎片的概念及导致的内存管理方式
4. I/O密集型进程与CPU密集型进程的区别

## 综合题

## 银行家算法

### 考点总结：
1. **Need矩阵计算**：
   - Need = Max - Allocation
2. **系统安全状态判断**：
   - 通过计算剩余资源和进程的需求判断系统是否处于安全状态。
   - 安全序列的确定：检查进程是否可以顺利完成并释放资源。
3. **进程请求资源的判断**：
   - 检查请求的资源是否可以立即分配。
   - 判断系统在分配资源后是否仍然处于安全状态。

### 示例：
1. **例题：计算Need矩阵**：
   - Allocation:
     ```
     P0: 0 0 1 2
     P1: 0 1 0 0
     P2: 1 3 5 4
     P3: 0 6 3 2
     P4: 0 0 1 4
     ```
   - Max:
     ```
     P0: 0 0 1 2
     P1: 1 7 5 0
     P2: 2 3 5 6
     P3: 1 6 5 3
     P4: 0 6 5 6
     ```
   - Need = Max - Allocation:
     ```
     P0: 0 0 0 0
     P1: 1 6 5 0
     P2: 1 0 0 2
     P3: 1 0 2 1
     P4: 0 6 4 2
     ```

2. **例题：判断系统安全状态**：
   - Available: 1 5 2 0
   - 计算是否可以分配所有资源并完成所有进程：
     - 安全序列：P0, P2, P3, P1, P4

3. **例题：进程请求资源**：
   - P1请求：0 5 1 0
   - 判断是否可立即分配：是，系统在分配资源后仍然处于安全状态。

---

## 请求分页管理系统

### 考点总结：
1. **页表的建立和理解**：
   - 页表包含页号和对应的块号。
   - 根据逻辑地址和页表进行物理地址转换。

2. **逻辑地址到物理地址的转换**：
   - 逻辑地址分为页号和页内偏移。
   - 通过页号找到对应的块号，再通过偏移计算物理地址。

3. **缺页中断处理**：
   - 逻辑地址超出页表范围，发生页错误。
   - 操作系统处理缺页中断，加载所需页到内存并更新页表。

### 示例：
1. **例题：页表的建立**：
   - 页表内容：
     ```
     页号: 块号
     0: 21
     1: 25
     2: 30
     3: 无效
     4: 无效
     ```

2. **例题：逻辑地址转换**：
   - 给定逻辑地址9016：
     - 页号 = 9016 / 页大小 = 9016 / 256 = 35 余数为 151
     - 页号2对应块30
     - 物理地址 = 块号 × 页大小 + 页内偏移 = 30 × 256 + 151 = 7680 + 151 = 7831

3. **例题：缺页中断处理**：
   - 给定逻辑地址24600：
     - 页号 = 24600 / 页大小 = 24600 / 4096 = 6
     - 页号6超出页表范围，发生页错误。
     - 操作系统处理缺页中断，加载所需页到内存，更新页表。

---

## 信号量机制

### 考点总结：
1. **信号量的定义和初始化**：
   - `mutex`：控制缓冲区的互斥访问，初值为1
   - `empty`：记录空缓冲区的数量，初值为N
   - `full`：记录满缓冲区的数量，初值为0

2. **生产者-消费者问题**：
   - 生产者：生成产品并放入缓冲区。
   - 消费者：从缓冲区取出产品并处理。

3. **信号量操作**：
   - `wait`：检查并等待资源可用。
   - `signal`：释放资源并唤醒等待进程。

### 示例：
1. **伪代码描述**：
   ```c
   semaphore mutex = 1;
   semaphore empty = N;
   semaphore full = 0;

   void producer() {
       int item;
       while (true) {
           item = produce(); // 生成一个正整数
           wait(empty); // 等待有空的缓冲区单元
           wait(mutex); // 进入临界区
           put(item); // 将item放入缓冲区
           signal(mutex); // 离开临界区
           signal(full); // 增加满的缓冲区单元数
       }
   }

   void consumer_odd() {
       int item;
       while (true) {
           wait(full); // 等待有满的缓冲区单元
           wait(mutex); // 进入临界区
           item = getodd(); // 从缓冲区中取出一个奇数
           countodd(item); // 统计奇数个数
           signal(mutex); // 离开临界区
           signal(empty); // 增加空的缓冲区单元数
       }
   }

   void consumer_even() {
       int item;
       while (true) {
           wait(full); // 等待有满的缓冲区单元
           wait(mutex); // 进入临界区
           item = geteven(); // 从缓冲区中取出一个偶数
           counteven(item); // 统计偶数个数
           signal(mutex); // 离开临界区
           signal(empty); // 增加空的缓冲区单元数
       }
   }
   ```
