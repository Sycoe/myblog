

## 一、数据管理技术的发展的三阶段，各自缺点、优点 

### 人工管理阶段、文件系统阶段、数据库系统阶段

### 人工管理阶段
#### 优点：
- 灵活性高
- 成本低
#### 缺点：
- 效率低
- 容易出错
- 难以处理大规模数据
- 数据共享困难

### 文件系统阶段
#### 优点：
- 简单易用
- 灵活性高
- 直接访问数据
#### 缺点：
- 数据冗余和不一致性
- 数据共享和集成困难
- 数据安全和完整性不足
- 复杂查询能力差

### 数据库系统阶段
#### 优点：
- 数据完整性和一致性高
- 数据共享和集成方便
- 强大的查询能力
- 数据安全性高
- 高效的数据管理
#### 缺点：
- 复杂性增加
- 成本较高
- 扩展性有限
- 模式固定

## 二、实体、属性、联系、E-R图

(1)实体: 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。
(2)属性: 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。
(3)码:唯一标识实体的属性集称为码。 学生 学号、身高、年龄、 性别、.... 身份证号、学号 信息世界中的基本概念（续）
(4)实体型:用实体名及其属性名集合来抽象和刻画同类实体称为 实体型 
(5)实体集:学生（学号、年龄、性别、院系、专业、身份证号...） 同一类型实体的集合称为实体集 学生的集合 信息世界中的基本概念（续）
(6)联系
◼现实世界中事物内部以及事物之间的联系在信息世界 中反映为实体（型）内部的联系和实体（型）之间的联系。
◼实体内部的联系通常是指组成实体的各属性之间的联系 
◼实体之间的联系通常是指不同实体集之间的联系 
◼实体之间的联系有一对一、一对多和多对多等多种类型\



自主存取控制 常用存取控制方法 自主存取控制（Discretionary Access Control ，简称DAC） (1)同一用户对于不同的数据对象有不同的存取权限 (2)不同的用户对同一对象也有不同的权限 (3)用户还可将其拥有的存取权限转授给其他用户 标准SQL提供了自主存取控制的语句，即GRANT/REVOKE 优点 ➢能够通过授权机制有效地控制其他用户对敏感数据的存取 缺点 ➢可能存在数据的“无意泄露” ➢原因：这种机制仅仅通过对数据的存取权限来进行安全控 制，而数据本身并无安全性标记。 ➢解决：对系统控制下的所有主客体实施强制存取控制策略

授权－－将数据库中的某些对象的某些操作权限赋予某些用户。

![[Pasted image 20240528221529.png]]


授权使用GRANT语句： GRANT<权限>[,<权限>]... [ON <对象类型><对象名>] TO<用户>[,<用户>]... [WITH GRANTOPTION]; 注： (1)DBA拥有数据库操作的所有权限，可以将权限赋予其他用户。 (2)建立数据库对象有用户称为该对象的属主(OWNER)，他拥有该 对象的所有操作权限。 (3)接受权限的用户可以是一个或多个具体用户，也可以是全体用户 (PUBLIC)。 (4)指定了WITH GRANT OPTION子句,获得某种权限的用户还可以 把这种权限再授予别的用户；没有指定WITH GRANT OPTION子 句，获得某种权限的用户只能使用该权限，不能传播该权限。

强制存取控制（Mandatory Access Control，简称MAC） (1)每一个数据对象被标以一定的密级 (2)每一个用户也被授予某一个级别的许可证 (3)对于任意一个对象，只有具有合法许可证的用户才可以存取




### 4.2 数据库安全性控制

#### 4.2.1 自主存取控制 (DAC)
- **定义**: 自主存取控制允许用户对不同数据对象有不同权限，并可以将权限转授给其他用户。
- **优点**:
  - 有效控制对敏感数据的访问。
- **缺点**:
  - 存在“无意泄露”风险，因为只通过存取权限控制安全，数据本身无安全性标记。
- **实现**: 标准SQL提供GRANT/REVOKE语句进行自主存取控制。

#### 4.2.2 授权与回收
- **授权**:
  - 使用`GRANT`语句赋予权限。
  - `WITH GRANT OPTION`允许获得权限的用户再授予他人。
- **回收**:
  - 使用`REVOKE`语句收回权限。
  - `CASCADE`选项用于级联收回传递出去的权限。
- **示例**:
  - 创建角色: `CREATE ROLE R1;`
  - 授予权限: `GRANT SELECT, UPDATE, INSERT ON TABLE Student TO R1;`
  - 分配角色: `GRANT R1 TO 王平, 张明, 赵玲;`
  - 收回角色: `REVOKE R1 FROM 王平;`

#### 4.2.3 强制存取控制 (MAC)
- **定义**: 每个数据对象和用户都被标以密级，只有具有合法许可证的用户才可以存取。
- **规则**:
  - 用户的许可证级别>=对象密级时，用户可读取对象。
  - 用户的许可证级别<=对象密级时，用户可写入对象。
- **实现**:
  - 商用数据库如神通数据库安全版、南大通用数据库GBase 8s、达梦数据库、Oracle实现了强制存取控制。

### 5.1 实体完整性

#### 5.1.1 实体完整性定义
- **实体完整性**:
  - 确保表中每一行记录都是唯一的，并且主键列中的值不能为空。
  - 主键（Primary Key）是用于唯一标识表中每一行记录的字段或字段组合。
  - 主键的值必须唯一且不能为空。
  - 主键可以由单个列或多个列组成。

#### 5.1.2 实体完整性约束的创建
- **单属性主键**:
  - 列级定义:
    ```sql
    CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      Ssex CHAR(2),
      Sage SMALLINT,
      Sdept CHAR(20)
    );
    ```
  - 表级定义:
    ```sql
    CREATE TABLE Student (
      Sno CHAR(9),
      Sname CHAR(20) NOT NULL,
      Ssex CHAR(2),
      Sage SMALLINT,
      Sdept CHAR(20),
      PRIMARY KEY (Sno)
    );
    ```
- **多属性主键**:
  ```sql
  CREATE TABLE SC (
    Sno CHAR(9) NOT NULL,
    Cno CHAR(4) NOT NULL,
    Grade SMALLINT,
    PRIMARY KEY (Sno, Cno)
  );
  ```

### 5.2 参照完整性

#### 5.2.1 参照完整性定义
- **参照完整性**:
  - 确保表中的外键值必须在被引用的表中存在。
  - 外键（Foreign Key）用于在两表之间建立连接，使得数据库能够维护引用关系的一致性。
  - 外键列中的值必须在被引用表的主键列或唯一键列中存在。

#### 5.2.2 参照完整性约束的创建
- **创建外键**:
  ```sql
  CREATE TABLE SC (
    Sno CHAR(9) NOT NULL,
    Cno CHAR(4) NOT NULL,
    Grade SMALLINT,
    PRIMARY KEY (Sno, Cno),
    FOREIGN KEY (Sno) REFERENCES Student (Sno),
    FOREIGN KEY (Cno) REFERENCES Course (Cno)
  );
  ```

### 5.3 用户定义的完整性

#### 5.3.1 用户定义完整性定义
- **用户定义的完整性**:
  - 根据具体业务需求，在数据库设计中自定义的约束条件。
  - 常见的约束包括NOT NULL、UNIQUE、CHECK等。

#### 5.3.2 用户定义完整性约束的创建
- **NOT NULL**: 确保列值不能为空。
  ```sql
  CREATE TABLE Student (
    Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) NOT NULL,
    Ssex CHAR(2),
    Sage SMALLINT NOT NULL,
    Sdept CHAR(20)
  );
  ```
- **UNIQUE**: 确保列值唯一。
  ```sql
  CREATE TABLE Student (
    Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) NOT NULL,
    Ssex CHAR(2),
    Sage SMALLINT NOT NULL,
    Sdept CHAR(20),
    UNIQUE (Sname)
  );
  ```

### 5.4 CHECK子句

#### 5.4.1 CHECK子句定义
- **CHECK子句**:
  - 用于定义表列的取值范围，确保数据符合指定的条件。
  - 任何不符合CHECK条件的数据插入或更新操作将被拒绝。

#### 5.4.2 CHECK子句的创建
- **示例**:
  ```sql
  CREATE TABLE Student (
    Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) NOT NULL,
    Ssex CHAR(2) CHECK (Ssex IN ('男', '女')),
    Sage SMALLINT CHECK (Sage >= 0 AND Sage <= 100),
    Sdept CHAR(20)
  );
  ```

### 5.5 断言

#### 5.5.1 断言定义
- **断言**:
  - 一种完整性约束，声明整个数据库必须满足的条件。
  - 断言在数据库中全局生效，确保跨表的数据一致性。

#### 5.5.2 断言的创建
- **示例**:
  ```sql
  CREATE ASSERTION StudentAgeCheck
  CHECK (NOT EXISTS (
    SELECT * 
    FROM Student 
    WHERE Sage < 0 OR Sage > 100
  ));
  ```

### 5.6 触发器

#### 5.6.1 触发器定义
- **触发器**:
  - 一种自动执行的特殊存储过程，当特定的数据库事件（如INSERT、UPDATE、DELETE）发生时自动触发执行。
  - 触发器用于强制业务规则、审计跟踪和*维护复杂*的完整性约束。

#### 5.6.2 触发器的创建
- **示例**:
  ```sql
  CREATE TRIGGER CheckStudentAge
  BEFORE INSERT OR UPDATE ON Student
  FOR EACH ROW
  BEGIN
    IF :NEW.Sage < 0 OR :NEW.Sage > 100 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Age must be between 0 and 100');
    END IF;
  END;
  ```




回顾四例题

根据文档第四章知识中的安全性控制机制，可以利用数据库的自主存取控制（DAC）和角色（Roles）功能来实现各个队（team1、team2、team3等）的管理员自行管理相互之间不干涉。具体步骤如下：

### 1. 创建数据库用户

首先，为每个队的管理员创建一个独立的数据库用户。

```sql
CREATE USER team1_admin IDENTIFIED BY password1;
CREATE USER team2_admin IDENTIFIED BY password2;
CREATE USER team3_admin IDENTIFIED BY password3;
```

### 2. 创建角色

为每个队创建一个独立的角色，并赋予适当的权限。

```sql
CREATE ROLE team1_role;
CREATE ROLE team2_role;
CREATE ROLE team3_role;
```

### 3. 创建表格

创建统一使用的参赛队员表格 `participants`。

```sql
CREATE TABLE participants (
  sno CHAR(9) PRIMARY KEY,
  sname CHAR(20) NOT NULL,
  whichteam CHAR(10),
  role CHAR(20)
);
```

### 4. 授予角色权限

根据角色，为每个队的管理员授予管理自己队员的权限，确保他们只能访问和管理自己队的数据。

```sql
-- 授予 team1_role 管理 team1 的权限
GRANT SELECT, INSERT, UPDATE, DELETE ON participants TO team1_role;
GRANT team1_role TO team1_admin;

-- 授予 team2_role 管理 team2 的权限
GRANT SELECT, INSERT, UPDATE, DELETE ON participants TO team2_role;
GRANT team2_role TO team2_admin;

-- 授予 team3_role 管理 team3 的权限
GRANT SELECT, INSERT, UPDATE, DELETE ON participants TO team3_role;
GRANT team3_role TO team3_admin;
```

### 5. 创建视图和触发器

为了确保各个管理员只能管理自己的队员，可以创建视图和触发器来限制数据访问和操作。

#### 创建视图

为每个队创建一个视图，过滤各自队伍的数据。

```sql
CREATE VIEW team1_view AS
SELECT * FROM participants WHERE whichteam = 'team1';

CREATE VIEW team2_view AS
SELECT * FROM participants WHERE whichteam = 'team2';

CREATE VIEW team3_view AS
SELECT * FROM participants WHERE whichteam = 'team3';
```

#### 授予视图权限

授予各自队伍管理员对视图的权限。

```sql
GRANT SELECT, INSERT, UPDATE, DELETE ON team1_view TO team1_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON team2_view TO team2_admin;
GRANT SELECT, INSERT, UPDATE, DELETE ON team3_view TO team3_admin;
```

### 6. 创建触发器

创建触发器，确保插入和更新操作只能针对对应队伍的数据。

```sql
CREATE TRIGGER check_team1_before_insert
BEFORE INSERT ON participants
FOR EACH ROW
BEGIN
  IF :NEW.whichteam != 'team1' THEN
    RAISE_APPLICATION_ERROR(-20001, 'You can only manage team1 data.');
  END IF;
END;

CREATE TRIGGER check_team2_before_insert
BEFORE INSERT ON participants
FOR EACH ROW
BEGIN
  IF :NEW.whichteam != 'team2' THEN
    RAISE_APPLICATION_ERROR(-20002, 'You can only manage team2 data.');
  END IF;
END;

CREATE TRIGGER check_team3_before_insert
BEFORE INSERT ON participants
FOR EACH ROW
BEGIN
  IF :NEW.whichteam != 'team3' THEN
    RAISE_APPLICATION_ERROR(-20003, 'You can only manage team3 data.');
  END IF;
END;
```

通过上述步骤，利用数据库的用户标识与鉴别、自主存取控制、角色、视图和触发器等功能，可以实现各个队伍的管理员相互之间不干涉地自行管理自己队伍的参赛队员。