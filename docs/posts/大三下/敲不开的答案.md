2、
### **ret2libc的原理**
1. **覆盖返回地址**：
    - 利用缓冲区溢出漏洞，将栈中的**返回地址**覆盖为**库函数的入口地址**。
        
2. **构造参数**：
    - 在栈中覆盖返回地址之后填充**攻击者设定的参数**，使库函数执行时使用这些参数完成恶意行为。
        

### **绕过DEP的原因**

- DEP使栈内存**不可执行**，但ret2libc不注入代码，而是重用进程空间中已有的位于可执行的内存区域合法库函数代码。
- 攻击仅篡改返回地址和参数，库函数本身是合法且可执行的，符合DEP规则。

5、
### **绕过方式**


6、
 **1. 文件Fuzz测试**
- **特点**：使用**基于正常模板变异生成的畸形文件**测试软件解析漏洞，分为**盲测**和**智能测**。
 **2. 协议Fuzz测试**
- **特点**：针对**网络协议**构造畸形命令，探测协议解析漏洞，依赖协议逆向工程。
 **3. 组件Fuzz测试**
- **特点**：提取软件组件并分析其接口，构造测试用例驱动组件运行，监测异常。
**4. Web Fuzz测试**
- **特点**：针对Web应用输入点注入畸形数据，检测XSS等漏洞，通过Payload变异和盲打技术绕过过滤机制。

7、
（1）
  - `%s`表示**输出字符串**，函数会从栈中取出对应的参数作为`char*`指针，并打印该地址指向的字符串（直到遇到`\0`）。  
- **漏洞：  
  - 若格式字符串由用户控制（如`printf(str)`，`str="%s"`），函数会从栈中**读取一个未指定的地址**作为字符串指针，可能导致**内存数据泄露**。  
（2）`printf("2024%n", i)`（`i`为整型变量）
  - `%n`表示**将已输出的字符数写入内存**，函数会从栈中取出对应参数作为`int*`指针，并将字符数（此处为4，因为`2024`占4字符）写入地址。 
- **漏洞：  
  - 若`i`被错误传递为整型值而非指针，函数会将其视为内存地址，导致**向任意地址写入整数4**。  


8、
1. **反跟踪技术**  
   驻留内存监控系统运行，当用户使用`DIR`命令查看文件时，自动替换被感染文件的时间、日期、长度等信息，显示为感染前的正常状态。
2. **避开修改中断向量**  
   直接修改中断服务子程序，避免因修改中断向量触发反病毒软件的监测。
3. **请求在内存中的合法身份**  
   通过多种手段获得合法内存，从而进驻内存
 4. **维持宿主程序的外部特性**  
    截取中断，控制原文件显示原来的正确内容交给用户，掩盖感染痕迹。
 5. **不使用明显的感染标志**  
    通过一系列相关运算判断文件是否感染，避免被检测到感染标志。


# 问答题

（1）ROP 对比传统代码注入的优势
- 直接复用程序或库中已有的短指令片段，依赖已有代码，不改写或添加可执行内存，不触发不可执行栈或代码完整性校验。
- 通过组合 gadget，可构造任意计算逻辑。且每个 gadget 本身都是合法指令，整个链条~~看似~~正常调用返回，常规检测难以捕获。
（2）用两个 gadget 将 `%eax` 的值写入地址 `0x8000000C`
- Gadget r2：`pop %edx; ret`
- Gadget r1：`movl %eax, 8(%edx); ret`
构造栈布局（按调用顺序从栈顶向下放）：
```
[ ... 下一步返回地址 ]  
| r2 的地址           | ← ret 调用 gadget r2  
| 0x80000004          | ← pop %edx，把 0x80000004 装入 edx  
| r1 的地址           | ← ret 调用 gadget r1  
| （填充任意或下一步）|  
```
执行流程：
1. 执行 `pop %edx; ret` → edx = 0x80000004
2. 下一条 `ret` 跳到 `movl %eax, 8(%edx); ret` → 将 `%eax` 写入 `0x80000004 + 8 = 0x8000000C`
    