选填考察的知识点（具体考啥很难猜）

当攻击者准备攻击一个软件或系统的时候：
如果有可能，首先正常地安装这个目标软件/系统 
逆向工程，测试这 个目标里有什么可以利用的漏洞 
没得到许可？额 ……这是违法的你应该停下来
呵呵……这可是攻 击者，谁理你
如果发现了漏洞， 搞清楚利用它的正确姿势、利用它可以造成的后果 
在攻击者愿意的时 候，可以干坏事了 

注意：这个过程中攻击者=用户 

这个过程于是(仿效“中间人攻击”)得名Man-At-The-End 

![[eb72994e38081515f0faebe9a2327213.png]]


选择（5道）
内存漏洞
缓存溢出
堆溢出
格式化字符串攻击
代码混淆

填空（5道）
栈溢出覆盖
RA
EBP
实参
cookie

简答题（9道）
### **1、栈溢出的原理是什么？如何检测或避免？**
   栈溢出是因缓冲区写入越界，覆盖栈中关键数据，导致程序执行流被篡改的漏洞。核心机制源于**栈与缓冲区的反向增长方向**及**缺乏边界检查**。
   避免方法：**数据执行保护**（DEP）、栈帧中插入特殊值、**分离控制和数据栈**
### **2、ret2libc的原理是什么，为什么可以绕过DEP？**
原理：
	利用缓冲区溢出漏洞，将栈中的**返回地址**覆盖为**库函数的入口地址**。在栈中覆盖返回地址之后填充**攻击者设定的参数**，使库函数执行时使用这些参数完成恶意行为。
绕过原因：
- DEP使栈内存**不可执行**，但ret2libc不注入代码，而是重用进程空间中已有的位于可执行的内存区域合法库函数代码。
- 攻击仅篡改返回地址和参数，库函数本身是合法且可执行的，符合DEP规则。
### **3、为什么要用ASLR？**
  ASLR通过给内存布局的偏移做了随机化工作~~ASLR虽然不解决漏洞本身，但~~增加了漏洞利用的难度，64位操作系统中，ASLR能够提供更大的熵，即可随机的地址范围更大，因而具有很好的防利用效果
### **4、MATE模型原理是什么？列举两个实例**
  原理：攻击者位于终端，对终端计算资源有最高控制权限。向安装在受控终端上的软件程序发起攻击，以获悉、篡改软件的内部逻辑
  实例：盗版/破解、病毒/恶意代码分析
### **5、SQL注入如何绕过口令判断？**
1. **大小写绕过**
    - 当过滤仅检查特定大小写关键词（如`AND`/`OR`）时，使用**混合大小写**绕过检测。
2. **双写绕过**
    - 若过滤仅替换一次关键词，通过双写（如`oorr` → 过滤后变为`or`）绕过。
3. **等效符号替换**
    - 用逻辑运算符替代关键词：
        - `AND` → `&&`（URL编码为`%26%26`）。
        - `OR` → `||`。
4. **空格绕过**
    - **科学计数法+括号**：例如`1e1`或`(1)`替代空格。
    - **内联注释**：由于部分防火墙不检查注释内容，可利用注释符包裹关键词绕过。
5. **禁止逗号绕过**
    - 使用**子查询+JOIN联合查询**替代逗号分隔参数。
### **6、列举2种模糊测试，并说出其特点（四种都写了）**
	 1. 文件Fuzz测试
	 特点：使用基于正常模板变异生成的畸形文件测试软件解析漏洞，分为盲测和智能测。
	 2. 协议Fuzz测试
	 特点：针对网络协议构造畸形命令，探测协议解析漏洞，依赖协议逆向工程。
	 3. 组件Fuzz测试
	 特点：提取软件组件并分析其接口，构造测试用例驱动组件运行，监测异常。
	4. Web Fuzz测试
	 特点：针对Web应用输入点注入畸形数据，检测XSS等漏洞，通过Payload变异和盲打技术绕过过滤机制。
### **7、（1）printf（“%s”） （2）printf（“2024%n”，i）i为整型变量**
  （1）
  - `%s`表示**输出字符串**，函数会从栈中取出对应的参数作为`char*`指针，并打印该地址指向的字符串（直到遇到`\0`）。  
- **漏洞：  
  - 若格式字符串由用户控制（如`printf(str)`，`str="%s"`），函数会从栈中**读取一个未指定的地址**作为字符串指针，可能导致**内存数据泄露**。  
  （2）`printf("2024%n", i)`（`i`为整型变量）
  - `%n`表示**将已输出的字符数写入内存**，函数会从栈中取出对应参数作为`int*`指针，并将字符数（此处为4，因为`2024`占4字符）写入地址。 
- **漏洞：  
  - 若`i`被错误传递为整型值而非指针，函数会将其视为内存地址，导致**向任意地址写入整数4**。  
### **8、恶意软件的5种隐藏机制及效果**
1. **反跟踪技术**  
   驻留内存监控系统运行，当用户使用`DIR`命令查看文件时，自动替换被感染文件的时间、日期、长度等信息，显示为感染前的正常状态。
2. **避开修改中断向量**  
   直接修改中断服务子程序，避免因修改中断向量触发反病毒软件的监测。
3. **请求在内存中的合法身份**  
   通过多种手段获得合法内存，从而进驻内存
 4. **维持宿主程序的外部特性**  
    截取中断，控制原文件显示原来的正确内容交给用户，掩盖感染痕迹。
 5. **不使用明显的感染标志**  
    通过一系列相关运算判断文件是否感染，避免被检测到感染标志。
### **9、列出2种增加反编译难度的思路**
	1. 代码混淆。利用不透明谓词，条件分支混淆等方法构建类似软件水印等
	2. 加密程序集，调用时加载解密`*.dll`文件。
	3. 设计“逻辑炸弹”，当一个进程或程序被反复跟踪，就“引爆”整个程序，使程序崩溃，进而无法被反编译。
	 

综合题（2道）
1、（1）ROP对于代码注入的优势
 （2）add r1 ：mov1  %eax  8(%edx) ret
	 add r2：pop  %edx  ret
	 将eax的值写入到内存0X800000C中
	 ![[Pasted image 20250525161923.png|15*15]]
	 （1）ROP 对比传统代码注入的优势
	    直接复用程序或库中已有的短指令片段，依赖已有代码，不改写或添加可执行内存，不触发不可执行栈或代码完整性校验。
		通过组合 gadget，可构造任意计算逻辑。且每个 gadget 本身都是合法指令，整个链条~~看似~~正常调用返回，常规检测难以捕获。
	（2）用两个 gadget 将 `%eax` 的值写入地址 `0x8000000C`
		Gadget r2：`pop %edx; ret`
		Gadget r1：`movl %eax, 8(%edx); ret`
		构造栈布局（按调用顺序从栈顶向下放）：
		```
		[ ... 下一步返回地址 ]  
		| r2 的地址           | ← ret 调用 gadget r2  
		| 0x80000004          | ← pop %edx，把 0x80000004 装入 edx  
		| r1 的地址           | ← ret 调用 gadget r1  
		| （填充任意或下一步）|  
		```
		执行流程：
		1. 执行 `pop %edx; ret` → edx = 0x80000004
		2. 下一条 `ret` 跳到 `movl %eax, 8(%edx); ret` → 将 `%eax` 写入 `0x80000004 + 8 = 0x8000000C`

2、（1）未初始 静态
		初始 静态
		 局部
		 存在内存中的哪个段
   （2）栈溢出改进

（1）**局部**变量存放在**栈区**，如果使用 static 修饰，则存放在全局/静态区，与是否初始化无关。
**全局**变量存放在**全局/静态区**，静态存储区又包括 BSS 段和数据段，
**未初始化**的全局变量存放在 **BSS** 段，**已初始化**的全局变量则存放在**数据段**
（2）
1. **数据执行保护（DEP）**：通过设置内存页的NX位，防止数据段被执行。
2. **栈金丝雀（Stack Canaries）**：在栈帧中插入特定值，函数返回前检查其是否被篡改，以检测栈溢出。
3. **影子栈（Shadow Stack）**：维护一个独立的栈来存储返回地址，函数返回时验证其完整性。
4. **分离控制与数据栈（Separated Control- and Data-Stacks）**：将控制信息和数据存储在不同的栈中，防止数据溢出影响控制流。


补充：
- 代码段：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于**只读**。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
 ![[Pasted image 20250526192657.png]]