• 交换Hello消息，对于算法、 交换随机值等协商一致 
• 交换必要的密码参数，以便 双方得到统一的premaster secret 
• 交换证书和相应的密码信息 ，以便进行身份认证 
• 产生master secret 
• 把安全参数提供给SSL记录层 
• 检验双方是否已经获得同样的安全参数 
阶段1：建立安全功能，包括协议版本，会话标志，密码套件，压缩方法和初始随机数 
阶段2：服务器发送证书，密钥交换 ，请求证书。服务器发出问候消息阶段结束信号 
阶段3：客户端发送证书，客户发送密钥交换消息，客户端发送证书验证信息 
阶段4：改变密码套件并结束握手协议



下面给出对称型 Needham–Schroeder 公钥中心（KDC）协议的完整流程，包括每一步的消息结构、各方操作和安全意义。

---

## 参与方与符号

- **A**, **B**：要建立安全会话的两个主体
    
- **KDC**：密钥分发中心（Key Distribution Center）
    
- KAK_A，KBK_B：KDC 与 A、B 分别共享的长期对称密钥
    
- KsK_s：本次会话的临时对称会话密钥，由 KDC 生成
    
- N1,N2N_1, N_2：A、B 各自生成的随机数（Nonce），用以防重放、保证新鲜性
    
- IDA,IDBID_A, ID_B：A、B 的身份标识
    
- EK[X]E_{K}[X]：用密钥 KK 对消息 XX 做对称加密
    

---

## 协议流程

```
1) A → KDC：
      ID_A ∥ ID_B ∥ N₁

2) KDC → A：
      E_{K_A} [ K_s ∥ ID_B ∥ N₁ ∥ Ticket_{B} ]
   其中，Ticket_{B} = E_{K_B}[ K_s ∥ ID_A ]

3) A → B：
      Ticket_{B} ∥ E_{K_s}[ ID_A ∥ N₁' ]
   （有的版本用 N₁，有的用新随机 N₁'，此处可统一用 N₁）

4) B → A：
      E_{K_s}[ N₂ ]

5) A → B：
      E_{K_s}[ f(N₂) ]
```

下面逐步解析。

---

### 步骤 1：A 向 KDC 请求会话密钥

```
A → KDC:  ID_A ∥ ID_B ∥ N₁
```

- A 告诉 KDC：
    
    - “我是 A”（ID_A）
        
    - “我想和 B（ID_B）通信”
        
    - “请给我一个用于本次会话的随机数 N₁，以便后续验证新鲜性”
        

---

### 步骤 2：KDC 回复 A

```
KDC → A:  E_{K_A}[ K_s ∥ ID_B ∥ N₁ ∥ Ticket_{B} ]
```

- **K_s**：KDC 为 A 和 B 本次会话专门生成的临时对称密钥
    
- **N₁**：原封不动返回，保证了本次回复的“新鲜性”（防止旧消息重放）
    
- **ID_B**：明确本次密钥是给 A 与 B 使用，防止中间人混淆
    
- **Ticket_{B}**：KDC 用 B 的长期密钥 KBK_B 加密的凭证
    
    TicketB=EKB[ Ks∥IDA ] \text{Ticket}_{B} = E_{K_B}[\, K_s ∥ ID_A \,]
    
    只有 B 能解，内含会话密钥 KsK_s 和 A 的身份。
    

A 用自己与 KDC 共享的 KAK_A 解密，就得到 {Ks,IDB,N1,TicketB}\{K_s,ID_B,N_1,Ticket_{B}\}，验证 N1N_1 与自己发出的一致、ID_B 无误后，才放心使用 KsK_s 与 B 通信。

---

### 步骤 3：A 将凭证和验证信息转给 B

```
A → B:  Ticket_{B} ∥ E_{K_s}[ ID_A ∥ N₁ ]
```

- A 把 KDC 给的 Ticket_{B}（加密块）直接转发给 B
    
- 同时再用会话密钥 KsK_s 加密“我是 A”及随机数 N₁，供 B 验证
    
- B 解开 Ticket_{B}，取得 {Ks,IDA}\{K_s,ID_A\}，然后用该 KsK_s 解开第二部分，验证 A 的身份和 N₁。
    

---

### 步骤 4：B 向 A 证明自己也掌握了会话密钥

```
B → A:  E_{K_s}[ N₂ ]
```

- B 生成新的随机数 N2N₂，用 KsK_s 加密，发给 A
    
- 这一消息证明：只有真正拿到 K_s 的 B，才能正确地对 N₂ 加密
    

---

### 步骤 5：A 最后回应，完成身份验证与新鲜性验证

```
A → B:  E_{K_s}[ f(N₂) ]
```

- f(N2)f(N₂) 可以是对 N2N₂ 的简单变换（如 N2−1N₂ - 1 或哈希），
    
- B 解密后检查 f(N2)f(N₂) 是否正确，确认 A 真正拥有 KsK_s。
    

---

## 安全性与性质

1. **认证（Authentication）**
    
    - A 确认消息来自 KDC（因为能解开 EKAE_{K_A}）；
        
    - B 确认消息来自 KDC（因为能解开 EKBE_{K_B}）；
        
    - A、B 相互确认对方确实拥有会话密钥 KsK_s。
        
2. **新鲜性（Freshness）**
    
    - 随机数 N1,N2N₁,N₂ 防止重放攻击。
        
3. **机密性（Confidentiality）**
    
    - 会话密钥 KsK_s 只有 A、B、KDC 三方知道；
        
    - 而 A 与 B 之间的后续通信都用 KsK_s 加密。
        
4. **可扩展性**
    
    - 每次会话 KDC 都生成新的 KsK_s，无需 A、B 事先共享大量密钥。
        

---

这样，Needham–Schroeder 协议就在 5 步内实现了 A 和 B 在不事先直接共享密钥的情况下，通过可信 KDC 安全地协商出一个对称会话密钥，并完成相互认证。