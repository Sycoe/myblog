import{_ as a,c as r,o as e,af as o}from"./chunks/framework.B0E2DVLT.js";const c=JSON.parse('{"title":"python实现TSP","description":"","frontmatter":{},"headers":[],"relativePath":"posts/数据分析/TSP.md","filePath":"posts/数据分析/TSP.md"}'),s={name:"posts/数据分析/TSP.md"};function n(l,t,d,i,h,p){return e(),r("div",null,t[0]||(t[0]=[o('<h3 id="目的-找到最短路线-访问一组位置的每个成员并返回起点" tabindex="-1">目的：找到最短路线，访问一组位置的每个成员并返回起点 <a class="header-anchor" href="#目的-找到最短路线-访问一组位置的每个成员并返回起点" aria-label="Permalink to &quot;目的：找到最短路线，访问一组位置的每个成员并返回起点&quot;">​</a></h3><table tabindex="0"><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb" target="_blank" rel="noreferrer">Python 中的 TSP 教程</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td><a href="http://norvig.com/" target="_blank" rel="noreferrer">彼得·诺维格 （Peter Norvig</a>） 对 TSP 的精彩介绍</td><td></td></tr><tr><td><a href="https://www.youtube.com/watch?v=STbkQbsIYVQ" target="_blank" rel="noreferrer">切割平面法</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>YouTube 视频（以 Siri 的声音播放）</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/poke/" target="_blank" rel="noreferrer">口袋妖怪围棋之旅</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>前往 Catch &#39;em All 的最短路线</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/county/" target="_blank" rel="noreferrer">额外里程之旅</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>驱车前往美国所有 3100 个县城</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/college/" target="_blank" rel="noreferrer">大学之旅女王</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>参观 647 所大学的最佳公路旅行</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/road/austria.html" target="_blank" rel="noreferrer">奥地利徒步之旅</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>欣赏100座山峰的景色</td><td></td></tr><tr><td><a href="http://www.scientificamerican.com/article.cfm?id=case-traveling-salesman-unsolvable-limits-computation" target="_blank" rel="noreferrer">《科学美国人》</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>关于Yogi Berra和TSP的短片</td><td></td></tr><tr><td><a href="http://www.travellingsalesmanmovie.com/" target="_blank" rel="noreferrer">旅行推销员</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>惊悚电影以 TSP 的解决方案为中心</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/data/ml/monalisa.html" target="_blank" rel="noreferrer">蒙娜丽莎 TSP</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>1,000 个城市挑战问题的 1,000 美元奖金。</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/pla85900/" target="_blank" rel="noreferrer">PLA85900</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>85,900 个城市 TSP 的解决方案。</td><td></td></tr><tr><td><a href="https://www.math.uwaterloo.ca/tsp/iowa/" target="_blank" rel="noreferrer">爱荷华州之旅</a></td><td><img src="https://www.math.uwaterloo.ca/tsp/img/trans.gif" alt=""></td><td>99 个县竞选之旅的最佳路线。</td><td></td></tr></tbody></table><h1 id="python实现tsp" tabindex="-1">python实现TSP <a class="header-anchor" href="#python实现tsp" aria-label="Permalink to &quot;python实现TSP&quot;">​</a></h1><h4 id="alltours-tsp" tabindex="-1">alltours_tsp <a class="header-anchor" href="#alltours-tsp" aria-label="Permalink to &quot;alltours_tsp&quot;">​</a></h4><p><strong>所有游览算法</strong>：生成所有可能的城市游览，并选择最短的游览（游览时间最短的游览） <strong>所有非冗余游览算法</strong>：武断地说，所有旅行都必须从城市集中的第一个城市开始。将第一个城市拉出来，然后将其重新固定到其余城市的所有排列中。<code>(1, 2, 3)``(2, 3, 1)``(3, 1, 2)</code> -借此机会将游览构建为列表而不是元组 -我们可以验证 3 个城市现在只有 2 个旅游（不是 6 个），4 个城市有 6 个旅游（不是 24 个）</p><h5 id="欧几里得-tsp" tabindex="-1">欧几里得 TSP <a class="header-anchor" href="#欧几里得-tsp" aria-label="Permalink to &quot;欧几里得 TSP&quot;">​</a></h5><p><strong>是重要的特例</strong>，其中任何两个城市之间的距离是欧几里得距离，即二维平面中点之间的直线距离</p><p><strong>近似算法——如果我们愿意接受一个很短但不能保证最短的旅行</strong></p><ul><li><strong>最近邻算法</strong>：让游览从一个城市到最近的邻居。重复。</li><li><strong>贪婪算法</strong>：找到任意两个城市之间的最短距离，并将该边缘包含在游览中。重复。 <strong>近似优化</strong></li><li><strong>重复策略</strong>：采用某种算法并多次重新运行，每次改变某些方面，并采用得分最高的解决方案。</li><li><strong>更改策略</strong>：使用一些算法来创建一个解决方案，然后对解决方案进行小的更改以改进它。</li><li><strong>集成策略</strong>：采用两种或多种算法，将它们全部应用于问题，并选择最佳解决方案。</li></ul><h4 id="nn-tsp" tabindex="-1">nn_tsp <a class="header-anchor" href="#nn-tsp" aria-label="Permalink to &quot;nn_tsp&quot;">​</a></h4><p><strong>最近邻算法</strong>：从任何城市开始，每一步都通过前一个城市，移动到尚未访问的最近邻居</p><h4 id="repeated-nn-tsp" tabindex="-1">repeated_nn_tsp <a class="header-anchor" href="#repeated-nn-tsp" aria-label="Permalink to &quot;repeated_nn_tsp&quot;">​</a></h4><p><strong>重复最近邻算法</strong>：给出一个可选参数，尝试从不同城市开始，抽取指定大小的随机样本的功能</p><h4 id="测试函数" tabindex="-1">测试函数 <a class="header-anchor" href="#测试函数" aria-label="Permalink to &quot;测试函数&quot;">​</a></h4><p><strong>“地图”</strong>：表示一组城市的多重试验 <strong>标杆</strong>：在标准输入集合上运行函数，以比较其性能 <strong>比较多种算法</strong>：打印汇总统计数据，游览长度的平均值、标准差、最小值和最大值，以及所花费的时间以及城市集的数量和大小 <strong>多少个起始城市最适合</strong>：25~50</p><h4 id="异常值检查-更改策略" tabindex="-1"><strong>异常值检查</strong>(更改策略) <a class="header-anchor" href="#异常值检查-更改策略" aria-label="Permalink to &quot;**异常值检查**(更改策略)&quot;">​</a></h4><p><strong>区段（Segment）</strong>：游览形成循环，但区段没有循环，它的两端都是开放式的，会形成如下规划：<code>[A, B, C, D]</code> <code>[A, B]</code> <code>[B, C, D]</code> <code>[A, B, C, D]</code> <code>[A, B, C, D]</code> <code>D</code> <code>A</code><strong>反转路段改变行程</strong>： ![[Pasted image 20240716165103.png]] 将红改为绿，得到如下改变<code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code> <code>[5, 6, 7, 8, 9]</code> ——&gt; <code>[0, 1, 2, 3, 4, 9, 8, 7, 6, 5]</code> <code>[5, 6, 7, 8, 9]</code></p><h4 id="非随机地图" tabindex="-1">非随机地图 <a class="header-anchor" href="#非随机地图" aria-label="Permalink to &quot;非随机地图&quot;">​</a></h4><p>真实的地图上工作，基于实际公路旅行距离而不是直线距离的旅行</p><h5 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h5><p>维护一组区段，每个城市都定义了自己的 1 个城市区段。找到连接两个不同区段的两个端点的最短边，并将这些区段与该边连接起来。重复，直到我们形成一个游览所有城市的路段。 看不懂惹…… 详细草图：</p><ol><li>预先计算<strong>边</strong>列表，首先按最短边排序。边缘是一对城市;如果列表包含，则它不包含 ，并且从不包含 。<code>(A, B)``(B, A)``(A, A)</code></li><li>维护将<strong>端点</strong>映射到<strong>段</strong>的字典，例如 .最初，每个城市都是其自己的 1 个城市长段的端点，但当我们将区段连接在一起时，一些城市不再是端点，并从字典中删除。<code>{A: [A, B, C, D], D: [A, B, C, D]}</code></li><li>按最短先的顺序遍历边缘。当您找到一条边，使得 和 都是不同段的端点时，请将这两个段连接在一起。维护终结点字典以反映此新段。创建时停止<code>(A, B)``A``B</code><strong>贪婪算法比最近邻效果差，但它速度很快（尤其是在大地图上）</strong></li></ol><h5 id="可视化贪婪算法" tabindex="-1">可视化贪婪算法 <a class="header-anchor" href="#可视化贪婪算法" aria-label="Permalink to &quot;可视化贪婪算法&quot;">​</a></h5><p>看代码</p><h4 id="分而治之" tabindex="-1">分而治之 <a class="header-anchor" href="#分而治之" aria-label="Permalink to &quot;分而治之&quot;">​</a></h4><p><strong>方法</strong>：</p><ul><li>将城市集一分为二。</li><li>为每一半找到一个旅游。</li><li>将这两个旅行合二为一。 <strong>诀窍：</strong> 当 <em>n</em> 很小时，可以直接完成分半。 当 <em>n</em> 很大，第 2 步通过递归调用完成，将一半分成两个较小的一半。 <strong>合二为一的操作：</strong> 首先，我们考虑从两个巡游中的每一个中删除一条边的所有方法。如果我们从游览中删除一条边，我们会得到一个线段。 对这些线段进行旋转，任何候选组合巡回都包括对第一次巡回进行轮换，并在其后面附加第二次巡回巡回的轮换 但有一点需要注意：当我们去附加两个部分时，有两种方法可以做到这一点——要么保持第二部分不变，要么反转第二部分。 <strong>与贪婪算法或最近邻算法相比，分而治之的优化帮助要小</strong></li></ul><h2 id="其他经典算法" tabindex="-1"><strong>其他经典算法</strong> <a class="header-anchor" href="#其他经典算法" aria-label="Permalink to &quot;**其他经典算法**&quot;">​</a></h2><h4 id="最小生成树算法-mst-tsp" tabindex="-1">最小生成树算法：<code>mst_tsp</code> <a class="header-anchor" href="#最小生成树算法-mst-tsp" aria-label="Permalink to &quot;最小生成树算法：`mst_tsp`&quot;">​</a></h4><p><strong>最小生成树遍历算法：</strong> 构造最小生成树，然后进行预序遍历。这将为您提供一个保证不超过最小旅行两倍的旅行。 <strong>方法</strong>：列出所有边并对其进行排序，最短的先排序。 将一棵树初始化为单根城市（我们将任意删除第一个城市）。现在重复以下操作，直到树包含所有城市：找到将树中的城市 （A） 与树中尚未存在的城市 （B） 连接起来的最短边，并将 B 添加到树中 A 的子级列表中。</p><h5 id="最小生成树算法的关键作用——可保证行程长度" tabindex="-1">最小生成树算法的关键作用——可保证行程长度 <a class="header-anchor" href="#最小生成树算法的关键作用——可保证行程长度" aria-label="Permalink to &quot;最小生成树算法的关键作用——可保证行程长度&quot;">​</a></h5><p>至少最坏情况只有最优的两倍，虽然实际过程中，贪心和最邻近更好用</p><h4 id="动态规划held-karp-算法-hk-tsp" tabindex="-1">动态规划Held-Karp 算法：<code>hk_tsp</code> <a class="header-anchor" href="#动态规划held-karp-算法-hk-tsp" aria-label="Permalink to &quot;动态规划Held-Karp 算法：`hk_tsp`&quot;">​</a></h4><p>一种用于查找<strong>最佳</strong>游览的算法，而<strong>不是近似</strong>游览 举例<strong>关键属性</strong>： 给定一个起点城市 A、一个终点城市 C 和一组中间城市 B，那么在所有可能的路段中，从 A 开始，到 C 结束，并且只经过 B 中的所有城市，只有这些路段中最短的路段才能成为最佳游览的一部分。</p><h4 id="其他算法集成ensemble-tsp" tabindex="-1">其他算法集成<code>ensemble_tsp</code> <a class="header-anchor" href="#其他算法集成ensemble-tsp" aria-label="Permalink to &quot;其他算法集成`ensemble_tsp`&quot;">​</a></h4><p>慢死……主要还是看代码和执行时间</p><h1 id="进一步探索" tabindex="-1">进一步探索 <a class="header-anchor" href="#进一步探索" aria-label="Permalink to &quot;进一步探索&quot;">​</a></h1><ul><li><strong>线性规划</strong>：lingo运筹学等</li><li><strong>启发式算法</strong>：有许多方法可以使用启发式估计来找到好的（但不是最佳的）游览。例如，_蚁群优化算法_会随机选择跟随哪条边，然后用一些虚拟信息素强化最佳巡视中出现的边缘，而其他蚂蚁则倾向于跟随这些信息素。</li><li><strong>Lin-Kernighan 启发式</strong></li><li>**<a href="./.html">Christofides 算法</a>**保证了 3/2 的最佳行程长度（改进了最小生成树保证）。</li></ul>',38)]))}const m=a(s,[["render",n]]);export{c as __pageData,m as default};
