import{_ as o,c as t,o as l,af as a}from"./chunks/framework.B0E2DVLT.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/数据分析/校外实习记录.md","filePath":"posts/数据分析/校外实习记录.md"}'),i={name:"posts/数据分析/校外实习记录.md"};function r(c,e,d,s,n,u){return l(),t("div",null,e[0]||(e[0]=[a('<h2 id="_1、题目内容" tabindex="-1">1、题目内容 <a class="header-anchor" href="#_1、题目内容" aria-label="Permalink to &quot;1、题目内容&quot;">​</a></h2><p>写一个从网页里提取文本的方法</p><p>要求：</p><ol><li>不能包含html标签以及js、css、html代码、html元素属性等</li><li>提取出来的文本需要保留语义和断句，不能影响语义识别，以数组形式输出</li><li>需要包含header中涉及SEO和网站属性的文本，如title、meta、image标签的alt属性等</li><li>需要支持各种类型的站点，包括普通html、动态js渲染的网页等，动态网页可借助屋头浏览器渲染，方案越轻量越好</li><li>尽量轻便高效，不要依赖太大的组件</li></ol><h2 id="_2、那程序要做的是什么呢-用什么方法达到什么效果" tabindex="-1">2、那程序要做的是什么呢（用什么方法达到什么效果） <a class="header-anchor" href="#_2、那程序要做的是什么呢-用什么方法达到什么效果" aria-label="Permalink to &quot;2、那程序要做的是什么呢（用什么方法达到什么效果）&quot;">​</a></h2><p>（1）HTTP/浏览器 拉取 用什么方法把写这个页面的代码扒下来呢 要分动态和静态 静态抓取：用 requests（或 urllib3）带重试（Retry + HTTPAdapter）快速获取 HTML； 动态抓取：用轻量级浏览器自动化 —— Playwright page.goto(url, wait_until=&quot;networkidle&quot;) 保证 JS 执行完毕 滚动触发懒加载 / 无限加载</p><p>（2）HTML 清洗 真正的文本在哪里？ 网页分为：<code>&lt;script&gt;、&lt;template&gt;、&lt;style&gt;</code>几个部分 但真正的文本只在<code>&lt;template&gt;</code>中的html属性块中包裹 所以我们得把另两个渲染交互用的模块全部k掉</p><p>同时要整理html逻辑，所以最终要<strong>以dom树型</strong>结构一层一层输出</p><p>（3）元数据提取 多找几个种类的元数据，整理到数组中，用 <code> if &#39;xxx&#39; in rels: m[&#39;xxx&#39;] =</code> 这种提取到json数组的最前面，用作标识 要注意，如果没有这一项，就不输出了，即抓取后结果是空的，就删掉这一项</p><p>（4）语义块抽取 怎么从大量代码中找到少量文字呢 把读取下来的html代码中的，明显是代码的，比如<code>&lt;div class=&quot;&quot;&gt;</code> 在我们的实现中，用 <code>clean_soup</code> 去掉废标签 就去掉这一层，这样如果网站中出现解释说明用的示例代码，是不会被去掉的</p><p>又怎么把少量的一大堆文字整理出逻辑呢 将文字提取出来后，用<code>parts = re.split(r&#39;()&#39;, text)</code>做以符号为依据的分词 再加上nltk这种智能化的语料库辅助分词， 至少不会一段或者说一个数组里有一大坨字，效果还是要视网站复杂程度而订</p><p>在测试中，还发现有很多内容，由于被渲染等原因被重复扒取 所以给出方案：<strong>去重 &amp; 子串过滤</strong>，从而减少对文本逻辑产生影响的因素</p><ul><li>完全重复块抛弃</li><li>如果一个块完全包含于另一个更长块，则抛弃短块</li></ul><p>（5）数组输出 输出唯一要注意的问题就是，不要让输出的语序错乱</p><p>（6）找多种场景的网站并做测试 采用半自动化的，在命令行中输入合法网站输出 输出结果写入json文件，并在日志中事先反馈记录</p><ul><li>INFO：抓取方式、动态/静态、块数、词数、输出路径</li><li>WARNING / ERROR：抓取失败、解析异常</li></ul><h2 id="_3、那么现在我们来实现一下吧" tabindex="-1">3、那么现在我们来实现一下吧 <a class="header-anchor" href="#_3、那么现在我们来实现一下吧" aria-label="Permalink to &quot;3、那么现在我们来实现一下吧&quot;">​</a></h2><h3 id="一-最简单的版本" tabindex="-1">（一）最简单的版本 <a class="header-anchor" href="#一-最简单的版本" aria-label="Permalink to &quot;（一）最简单的版本&quot;">​</a></h3><ul><li><strong>静态抓取</strong>：<code>requests.get(url)</code></li><li><strong>全页文本</strong>：<code>BeautifulSoup(response.text).get_text()</code> 或 <code>lxml.html.fromstring(...).text_content()</code></li><li><strong>分句</strong>：用中英文标点做换行分句</li></ul><blockquote><p><strong>优点</strong>：实现快、依赖少。</p><p><strong>缺点</strong>：</p><ul><li>会把导航、脚本、样式、属性一起抓下来；</li><li>句子划分效果差，比如1. xxx...这里面有好多英文句号，如此分句会破坏语义；</li><li>完全不考虑动态内容；</li><li>不抓 meta、link、alt、JSON‑LD。</li></ul></blockquote><h3 id="二-改进-分块提取-元数据补充" tabindex="-1">（二）改进：分块提取 &amp; 元数据补充 <a class="header-anchor" href="#二-改进-分块提取-元数据补充" aria-label="Permalink to &quot;（二）改进：分块提取 &amp; 元数据补充&quot;">​</a></h3><h4 id="_1-元数据抓取" tabindex="-1">1. 元数据抓取 <a class="header-anchor" href="#_1-元数据抓取" aria-label="Permalink to &quot;1. 元数据抓取&quot;">​</a></h4><ul><li>遍历 <code>&lt;title&gt;</code>、<code>&lt;meta&gt;</code>（charset/name/property/http‑equiv）、<code>&lt;link&gt;</code>（rel/type）、<code>&lt;img alt&gt;</code>、<code>&lt;script type=&quot;application/ld+json&quot;&gt;</code></li><li><strong>过滤空 <code>alt</code></strong> 保留有效描述</li></ul><h4 id="_2-语义化正文分块" tabindex="-1">2. 语义化正文分块 <a class="header-anchor" href="#_2-语义化正文分块" aria-label="Permalink to &quot;2. 语义化正文分块&quot;">​</a></h4><ul><li><strong>分块</strong>：只抓常见显示标签<br><code>h1…h6, p, li, dd, dt, blockquote, pre, code, span, small, a, button, label, option, summary</code></li><li><strong>断句</strong>： <ul><li>加入nltk库辅助断句</li></ul></li></ul><h4 id="_3-工程化" tabindex="-1">3.工程化 <a class="header-anchor" href="#_3-工程化" aria-label="Permalink to &quot;3.工程化&quot;">​</a></h4><ul><li><strong>requests</strong>：<code>Retry</code> + <code>HTTPAdapter</code>，提高对网络问题导致异常的容错</li><li><strong>日志</strong>：<code>INFO</code> / <code>WARNING</code> / <code>ERROR</code> 明确抓取与解析流程</li><li><strong>命令行</strong>：<code>--dynamic</code> / <code>--text</code> / <code>-o</code> 输出</li><li><strong>模块化</strong>：清晰划分 <code>fetch_html</code>、<code>extract_meta</code>、<code>clean_soup</code>、<code>extract_blocks_from_soup</code>、<code>extract_quotes_special</code>、<code>extract_blocks</code>、<code>extract_url</code></li></ul><blockquote><p><strong>难点</strong>：</p><ul><li><p><code>get_text()</code> 默认换行难以控制，会把一个 <code>&lt;p&gt;</code> 内的多句拆得过碎。</p></li><li><p>部分标签如 <code>&lt;code&gt;</code>、<code>&lt;pre&gt;</code> 要按行保留，不做句子拆分。</p></li><li><p>一些可视化元素（按钮、链接）也要抓。</p></li><li><p>nltk库对中文支持不足，分句仍出现问题</p></li></ul></blockquote><h3 id="三-特殊场景优化" tabindex="-1">（三）特殊场景优化 <a class="header-anchor" href="#三-特殊场景优化" aria-label="Permalink to &quot;（三）特殊场景优化&quot;">​</a></h3><h4 id="_1-动态抓取" tabindex="-1">1. 动态抓取 <a class="header-anchor" href="#_1-动态抓取" aria-label="Permalink to &quot;1. 动态抓取&quot;">​</a></h4><ul><li>增加 Playwright 支持： <ul><li><code>page.goto(..., wait_until=&quot;networkidle&quot;)</code></li><li>无限滚动：<code>window.scrollTo</code> + 比较 <code>document.body.scrollHeight</code></li><li>展开 <code>&lt;details&gt;</code></li></ul></li></ul><h4 id="_2-quotes-专属" tabindex="-1">2. Quotes 专属 <a class="header-anchor" href="#_2-quotes-专属" aria-label="Permalink to &quot;2. Quotes 专属&quot;">​</a></h4><ul><li><code>quotes.toscrape.com/js</code>： <ul><li><code>.quote span.text</code> → 引文</li><li><code>.quote small.author</code> → 作者</li><li><code>.quote a.tag</code> → 标签</li></ul></li></ul><h4 id="_3-books-to-scrape-侧栏分类" tabindex="-1">3. Books to Scrape 侧栏分类 <a class="header-anchor" href="#_3-books-to-scrape-侧栏分类" aria-label="Permalink to &quot;3. Books to Scrape 侧栏分类&quot;">​</a></h4><ul><li><code>div.side_categories a</code>：导航分类文本也要抓。</li></ul><h4 id="_4-html-注释" tabindex="-1">4. HTML 注释 <a class="header-anchor" href="#_4-html-注释" aria-label="Permalink to &quot;4. HTML 注释&quot;">​</a></h4><ul><li>有时页面中会藏着有用的注释，故单独 <code>find_all(string=isinstance(Comment))</code> 并保留。</li></ul><h4 id="_5-去重与后处理" tabindex="-1">5.去重与后处理 <a class="header-anchor" href="#_5-去重与后处理" aria-label="Permalink to &quot;5.去重与后处理&quot;">​</a></h4><ol><li><strong>合并孤立 <code> “&lt;” “tag” “&gt;”</code></strong> → <code>&lt;tag&gt;</code></li><li><strong>初级去重</strong>：完全相同的块只留一份</li><li><strong>子串过滤</strong>：如果某块严格被另一个更长块包含，则丢弃短块</li></ol>',39)]))}const g=o(i,[["render",r]]);export{p as __pageData,g as default};
