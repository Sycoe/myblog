import{_ as t,c as r,o as e,af as n}from"./chunks/framework.B0E2DVLT.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/大三下/软件系统.md","filePath":"posts/大三下/软件系统.md"}'),s={name:"posts/大三下/软件系统.md"};function a(l,o,i,d,g,c){return e(),r("div",null,o[0]||(o[0]=[n(`<p>选填考察的知识点（具体考啥很难猜）</p><p>当攻击者准备攻击一个软件或系统的时候： 如果有可能，首先正常地安装这个目标软件/系统 逆向工程，测试这 个目标里有什么可以利用的漏洞 没得到许可？额 ……这是违法的你应该停下来 呵呵……这可是攻 击者，谁理你 如果发现了漏洞， 搞清楚利用它的正确姿势、利用它可以造成的后果 在攻击者愿意的时 候，可以干坏事了</p><p>注意：这个过程中攻击者=用户</p><p>这个过程于是(仿效“中间人攻击”)得名Man-At-The-End</p><p>![[eb72994e38081515f0faebe9a2327213.png]]</p><p>选择（5道） 内存漏洞 缓存溢出 堆溢出 格式化字符串攻击 代码混淆</p><p>填空（5道） 栈溢出覆盖 RA EBP 实参 cookie</p><p>简答题（9道）</p><h3 id="_1、栈溢出的原理是什么-如何检测或避免" tabindex="-1"><strong>1、栈溢出的原理是什么？如何检测或避免？</strong> <a class="header-anchor" href="#_1、栈溢出的原理是什么-如何检测或避免" aria-label="Permalink to &quot;**1、栈溢出的原理是什么？如何检测或避免？**&quot;">​</a></h3><p>栈溢出是因缓冲区写入越界，覆盖栈中关键数据，导致程序执行流被篡改的漏洞。核心机制源于<strong>栈与缓冲区的反向增长方向</strong>及<strong>缺乏边界检查</strong>。 避免方法：<strong>数据执行保护</strong>（DEP）、栈帧中插入特殊值、<strong>分离控制和数据栈</strong></p><h3 id="_2、ret2libc的原理是什么-为什么可以绕过dep" tabindex="-1"><strong>2、ret2libc的原理是什么，为什么可以绕过DEP？</strong> <a class="header-anchor" href="#_2、ret2libc的原理是什么-为什么可以绕过dep" aria-label="Permalink to &quot;**2、ret2libc的原理是什么，为什么可以绕过DEP？**&quot;">​</a></h3><p>原理： 利用缓冲区溢出漏洞，将栈中的<strong>返回地址</strong>覆盖为<strong>库函数的入口地址</strong>。在栈中覆盖返回地址之后填充<strong>攻击者设定的参数</strong>，使库函数执行时使用这些参数完成恶意行为。 绕过原因：</p><ul><li>DEP使栈内存<strong>不可执行</strong>，但ret2libc不注入代码，而是重用进程空间中已有的位于可执行的内存区域合法库函数代码。</li><li>攻击仅篡改返回地址和参数，库函数本身是合法且可执行的，符合DEP规则。</li></ul><h3 id="_3、为什么要用aslr" tabindex="-1"><strong>3、为什么要用ASLR？</strong> <a class="header-anchor" href="#_3、为什么要用aslr" aria-label="Permalink to &quot;**3、为什么要用ASLR？**&quot;">​</a></h3><p>ASLR通过给内存布局的偏移做了随机化工作<s>ASLR虽然不解决漏洞本身，但</s>增加了漏洞利用的难度，64位操作系统中，ASLR能够提供更大的熵，即可随机的地址范围更大，因而具有很好的防利用效果</p><h3 id="_4、mate模型原理是什么-列举两个实例" tabindex="-1"><strong>4、MATE模型原理是什么？列举两个实例</strong> <a class="header-anchor" href="#_4、mate模型原理是什么-列举两个实例" aria-label="Permalink to &quot;**4、MATE模型原理是什么？列举两个实例**&quot;">​</a></h3><p>原理：攻击者位于终端，对终端计算资源有最高控制权限。向安装在受控终端上的软件程序发起攻击，以获悉、篡改软件的内部逻辑 实例：盗版/破解、病毒/恶意代码分析</p><h3 id="_5、sql注入如何绕过口令判断" tabindex="-1"><strong>5、SQL注入如何绕过口令判断？</strong> <a class="header-anchor" href="#_5、sql注入如何绕过口令判断" aria-label="Permalink to &quot;**5、SQL注入如何绕过口令判断？**&quot;">​</a></h3><ol><li><strong>大小写绕过</strong><ul><li>当过滤仅检查特定大小写关键词（如<code>AND</code>/<code>OR</code>）时，使用<strong>混合大小写</strong>绕过检测。</li></ul></li><li><strong>双写绕过</strong><ul><li>若过滤仅替换一次关键词，通过双写（如<code>oorr</code> → 过滤后变为<code>or</code>）绕过。</li></ul></li><li><strong>等效符号替换</strong><ul><li>用逻辑运算符替代关键词： <ul><li><code>AND</code> → <code>&amp;&amp;</code>（URL编码为<code>%26%26</code>）。</li><li><code>OR</code> → <code>||</code>。</li></ul></li></ul></li><li><strong>空格绕过</strong><ul><li><strong>科学计数法+括号</strong>：例如<code>1e1</code>或<code>(1)</code>替代空格。</li><li><strong>内联注释</strong>：由于部分防火墙不检查注释内容，可利用注释符包裹关键词绕过。</li></ul></li><li><strong>禁止逗号绕过</strong><ul><li>使用<strong>子查询+JOIN联合查询</strong>替代逗号分隔参数。</li></ul></li></ol><h3 id="_6、列举2种模糊测试-并说出其特点-四种都写了" tabindex="-1"><strong>6、列举2种模糊测试，并说出其特点（四种都写了）</strong> <a class="header-anchor" href="#_6、列举2种模糊测试-并说出其特点-四种都写了" aria-label="Permalink to &quot;**6、列举2种模糊测试，并说出其特点（四种都写了）**&quot;">​</a></h3><pre><code> 1. 文件Fuzz测试
 特点：使用基于正常模板变异生成的畸形文件测试软件解析漏洞，分为盲测和智能测。
 2. 协议Fuzz测试
 特点：针对网络协议构造畸形命令，探测协议解析漏洞，依赖协议逆向工程。
 3. 组件Fuzz测试
 特点：提取软件组件并分析其接口，构造测试用例驱动组件运行，监测异常。
4. Web Fuzz测试
 特点：针对Web应用输入点注入畸形数据，检测XSS等漏洞，通过Payload变异和盲打技术绕过过滤机制。
</code></pre><h3 id="_7、-1-printf-s-2-printf-2024-n-i-i为整型变量" tabindex="-1"><strong>7、（1）printf（“%s”） （2）printf（“2024%n”，i）i为整型变量</strong> <a class="header-anchor" href="#_7、-1-printf-s-2-printf-2024-n-i-i为整型变量" aria-label="Permalink to &quot;**7、（1）printf（“%s”） （2）printf（“2024%n”，i）i为整型变量**&quot;">​</a></h3><p>（1）</p><ul><li><code>%s</code>表示<strong>输出字符串</strong>，函数会从栈中取出对应的参数作为<code>char*</code>指针，并打印该地址指向的字符串（直到遇到<code>\\0</code>）。</li><li>**漏洞： <ul><li>若格式字符串由用户控制（如<code>printf(str)</code>，<code>str=&quot;%s&quot;</code>），函数会从栈中<strong>读取一个未指定的地址</strong>作为字符串指针，可能导致<strong>内存数据泄露</strong>。<br> （2）<code>printf(&quot;2024%n&quot;, i)</code>（<code>i</code>为整型变量）</li><li><code>%n</code>表示<strong>将已输出的字符数写入内存</strong>，函数会从栈中取出对应参数作为<code>int*</code>指针，并将字符数（此处为4，因为<code>2024</code>占4字符）写入地址。</li></ul></li><li>**漏洞： <ul><li>若<code>i</code>被错误传递为整型值而非指针，函数会将其视为内存地址，导致<strong>向任意地址写入整数4</strong>。</li></ul></li></ul><h3 id="_8、恶意软件的5种隐藏机制及效果" tabindex="-1"><strong>8、恶意软件的5种隐藏机制及效果</strong> <a class="header-anchor" href="#_8、恶意软件的5种隐藏机制及效果" aria-label="Permalink to &quot;**8、恶意软件的5种隐藏机制及效果**&quot;">​</a></h3><ol><li><strong>反跟踪技术</strong><br> 驻留内存监控系统运行，当用户使用<code>DIR</code>命令查看文件时，自动替换被感染文件的时间、日期、长度等信息，显示为感染前的正常状态。</li><li><strong>避开修改中断向量</strong><br> 直接修改中断服务子程序，避免因修改中断向量触发反病毒软件的监测。</li><li><strong>请求在内存中的合法身份</strong><br> 通过多种手段获得合法内存，从而进驻内存</li><li><strong>维持宿主程序的外部特性</strong><br> 截取中断，控制原文件显示原来的正确内容交给用户，掩盖感染痕迹。</li><li><strong>不使用明显的感染标志</strong><br> 通过一系列相关运算判断文件是否感染，避免被检测到感染标志。</li></ol><h3 id="_9、列出2种增加反编译难度的思路" tabindex="-1"><strong>9、列出2种增加反编译难度的思路</strong> <a class="header-anchor" href="#_9、列出2种增加反编译难度的思路" aria-label="Permalink to &quot;**9、列出2种增加反编译难度的思路**&quot;">​</a></h3><pre><code>1. 代码混淆。利用不透明谓词，条件分支混淆等方法构建类似软件水印等
2. 加密程序集，调用时加载解密\`*.dll\`文件。
3. 设计“逻辑炸弹”，当一个进程或程序被反复跟踪，就“引爆”整个程序，使程序崩溃，进而无法被反编译。
</code></pre><p>综合题（2道） 1、（1）ROP对于代码注入的优势 （2）add r1 ：mov1 %eax 8(%edx) ret add r2：pop %edx ret 将eax的值写入到内存0X800000C中 ![[Pasted image 20250525161923.png|15*15]] （1）ROP 对比传统代码注入的优势 直接复用程序或库中已有的短指令片段，依赖已有代码，不改写或添加可执行内存，不触发不可执行栈或代码完整性校验。 通过组合 gadget，可构造任意计算逻辑。且每个 gadget 本身都是合法指令，整个链条<s>看似</s>正常调用返回，常规检测难以捕获。 （2）用两个 gadget 将 <code>%eax</code> 的值写入地址 <code>0x8000000C</code> Gadget r2：<code>pop %edx; ret</code> Gadget r1：<code>movl %eax, 8(%edx); ret</code> 构造栈布局（按调用顺序从栈顶向下放）： <code> [ ... 下一步返回地址 ] | r2 的地址 | ← ret 调用 gadget r2 | 0x80000004 | ← pop %edx，把 0x80000004 装入 edx | r1 的地址 | ← ret 调用 gadget r1 | （填充任意或下一步）| </code> 执行流程： 1. 执行 <code>pop %edx; ret</code> → edx = 0x80000004 2. 下一条 <code>ret</code> 跳到 <code>movl %eax, 8(%edx); ret</code> → 将 <code>%eax</code> 写入 <code>0x80000004 + 8 = 0x8000000C</code></p><p>2、（1）未初始 静态 初始 静态 局部 存在内存中的哪个段 （2）栈溢出改进</p><p>（1）<strong>局部</strong>变量存放在<strong>栈区</strong>，如果使用 static 修饰，则存放在全局/静态区，与是否初始化无关。 <strong>全局</strong>变量存放在<strong>全局/静态区</strong>，静态存储区又包括 BSS 段和数据段， <strong>未初始化</strong>的全局变量存放在 <strong>BSS</strong> 段，<strong>已初始化</strong>的全局变量则存放在<strong>数据段</strong> （2）</p><ol><li><strong>数据执行保护（DEP）</strong>：通过设置内存页的NX位，防止数据段被执行。</li><li><strong>栈金丝雀（Stack Canaries）</strong>：在栈帧中插入特定值，函数返回前检查其是否被篡改，以检测栈溢出。</li><li><strong>影子栈（Shadow Stack）</strong>：维护一个独立的栈来存储返回地址，函数返回时验证其完整性。</li><li><strong>分离控制与数据栈（Separated Control- and Data-Stacks）</strong>：将控制信息和数据存储在不同的栈中，防止数据溢出影响控制流。</li></ol><p>补充：</p><ul><li>代码段：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于<strong>只读</strong>。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 ![[Pasted image 20250526192657.png]]</li></ul>`,34)]))}const h=t(s,[["render",a]]);export{u as __pageData,h as default};
