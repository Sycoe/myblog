import{_ as i,c as a,o as l,af as n}from"./chunks/framework.B0E2DVLT.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/大二下/操作系统卷子.md","filePath":"posts/大二下/操作系统卷子.md"}'),p={name:"posts/大二下/操作系统卷子.md"};function t(h,s,e,k,r,d){return l(),a("div",null,s[0]||(s[0]=[n(`<h2 id="选择题" tabindex="-1">选择题 <a class="header-anchor" href="#选择题" aria-label="Permalink to &quot;选择题&quot;">​</a></h2><h3 id="操作系统概念" tabindex="-1">操作系统概念 <a class="header-anchor" href="#操作系统概念" aria-label="Permalink to &quot;操作系统概念&quot;">​</a></h3><ul><li>内核态执行指令：I/O指令</li><li>进程状态转换： <ul><li>从“运行”到“就绪”：出现比该进程优先级更高的进程</li></ul></li><li>动态重定位时机：程序运行时</li><li>时间片长度与响应时间：进程数越少，响应时间越小</li></ul><h3 id="多线程与调度" tabindex="-1">多线程与调度 <a class="header-anchor" href="#多线程与调度" aria-label="Permalink to &quot;多线程与调度&quot;">​</a></h3><ul><li>线程共享资源：进程P中打开的文件</li><li>多线程模型：1对多模型</li><li>调度算法防止饥饿：先来先服务、时间片轮转</li></ul><h3 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h3><ul><li>抖动处理：撤销部分进程</li><li>外部中断事件：除数为0</li><li>文件最大长度计算：1057KB</li></ul><h3 id="页面置换与死锁" tabindex="-1">页面置换与死锁 <a class="header-anchor" href="#页面置换与死锁" aria-label="Permalink to &quot;页面置换与死锁&quot;">​</a></h3><ul><li>LRU算法淘汰页：页号4</li><li>死锁的最小K值：4</li><li>信号量计算：已分配资源数1，等待资源数2</li></ul><h2 id="填空题" tabindex="-1">填空题 <a class="header-anchor" href="#填空题" aria-label="Permalink to &quot;填空题&quot;">​</a></h2><ol><li>死锁产生的四个必要条件：互斥使用、非剥夺、占有且等待、循环依赖</li><li>进程大小72766B，页面大小2KB，内部碎片大小为1182B，逻辑地址2471的页号为1，页内偏移地址为423</li><li>进程间通信方式：共享内存和消息传递队列</li><li>操作系统程序状态：内核态，用户程序状态：用户态，通过系统调用请求操作系统服务</li><li>两种I/O方法：同步I/O和异步I/O</li><li>文件访问方法：顺序访问和随机访问</li><li>临界区问题解决：互斥、进步和有限等待</li><li>CPU调度准则：CPU利用率、吞吐量、周转时间、等待时间、响应时间</li><li>页面置换类型：全局置换和局部置换</li><li>磁盘平均I/O时间：寻道时间、旋转延迟、数据传输时间</li></ol><h2 id="简答题" tabindex="-1">简答题 <a class="header-anchor" href="#简答题" aria-label="Permalink to &quot;简答题&quot;">​</a></h2><ol><li>使用系统调用创建子进程并执行新功能的流程</li><li>程序局部性原理</li><li>内部碎片和外部碎片的概念及导致的内存管理方式</li><li>I/O密集型进程与CPU密集型进程的区别</li></ol><h2 id="综合题" tabindex="-1">综合题 <a class="header-anchor" href="#综合题" aria-label="Permalink to &quot;综合题&quot;">​</a></h2><h2 id="银行家算法" tabindex="-1">银行家算法 <a class="header-anchor" href="#银行家算法" aria-label="Permalink to &quot;银行家算法&quot;">​</a></h2><h3 id="考点总结" tabindex="-1">考点总结： <a class="header-anchor" href="#考点总结" aria-label="Permalink to &quot;考点总结：&quot;">​</a></h3><ol><li><strong>Need矩阵计算</strong>： <ul><li>Need = Max - Allocation</li></ul></li><li><strong>系统安全状态判断</strong>： <ul><li>通过计算剩余资源和进程的需求判断系统是否处于安全状态。</li><li>安全序列的确定：检查进程是否可以顺利完成并释放资源。</li></ul></li><li><strong>进程请求资源的判断</strong>： <ul><li>检查请求的资源是否可以立即分配。</li><li>判断系统在分配资源后是否仍然处于安全状态。</li></ul></li></ol><h3 id="示例" tabindex="-1">示例： <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><ol><li><p><strong>例题：计算Need矩阵</strong>：</p><ul><li>Allocation:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>P0: 0 0 1 2</span></span>
<span class="line"><span>P1: 0 1 0 0</span></span>
<span class="line"><span>P2: 1 3 5 4</span></span>
<span class="line"><span>P3: 0 6 3 2</span></span>
<span class="line"><span>P4: 0 0 1 4</span></span></code></pre></div></li><li>Max:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>P0: 0 0 1 2</span></span>
<span class="line"><span>P1: 1 7 5 0</span></span>
<span class="line"><span>P2: 2 3 5 6</span></span>
<span class="line"><span>P3: 1 6 5 3</span></span>
<span class="line"><span>P4: 0 6 5 6</span></span></code></pre></div></li><li>Need = Max - Allocation:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>P0: 0 0 0 0</span></span>
<span class="line"><span>P1: 1 6 5 0</span></span>
<span class="line"><span>P2: 1 0 0 2</span></span>
<span class="line"><span>P3: 1 0 2 1</span></span>
<span class="line"><span>P4: 0 6 4 2</span></span></code></pre></div></li></ul></li><li><p><strong>例题：判断系统安全状态</strong>：</p><ul><li>Available: 1 5 2 0</li><li>计算是否可以分配所有资源并完成所有进程： <ul><li>安全序列：P0, P2, P3, P1, P4</li></ul></li></ul></li><li><p><strong>例题：进程请求资源</strong>：</p><ul><li>P1请求：0 5 1 0</li><li>判断是否可立即分配：是，系统在分配资源后仍然处于安全状态。</li></ul></li></ol><hr><h2 id="请求分页管理系统" tabindex="-1">请求分页管理系统 <a class="header-anchor" href="#请求分页管理系统" aria-label="Permalink to &quot;请求分页管理系统&quot;">​</a></h2><h3 id="考点总结-1" tabindex="-1">考点总结： <a class="header-anchor" href="#考点总结-1" aria-label="Permalink to &quot;考点总结：&quot;">​</a></h3><ol><li><p><strong>页表的建立和理解</strong>：</p><ul><li>页表包含页号和对应的块号。</li><li>根据逻辑地址和页表进行物理地址转换。</li></ul></li><li><p><strong>逻辑地址到物理地址的转换</strong>：</p><ul><li>逻辑地址分为页号和页内偏移。</li><li>通过页号找到对应的块号，再通过偏移计算物理地址。</li></ul></li><li><p><strong>缺页中断处理</strong>：</p><ul><li>逻辑地址超出页表范围，发生页错误。</li><li>操作系统处理缺页中断，加载所需页到内存并更新页表。</li></ul></li></ol><h3 id="示例-1" tabindex="-1">示例： <a class="header-anchor" href="#示例-1" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><ol><li><p><strong>例题：页表的建立</strong>：</p><ul><li>页表内容：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>页号: 块号</span></span>
<span class="line"><span>0: 21</span></span>
<span class="line"><span>1: 25</span></span>
<span class="line"><span>2: 30</span></span>
<span class="line"><span>3: 无效</span></span>
<span class="line"><span>4: 无效</span></span></code></pre></div></li></ul></li><li><p><strong>例题：逻辑地址转换</strong>：</p><ul><li>给定逻辑地址9016： <ul><li>页号 = 9016 / 页大小 = 9016 / 256 = 35 余数为 151</li><li>页号2对应块30</li><li>物理地址 = 块号 × 页大小 + 页内偏移 = 30 × 256 + 151 = 7680 + 151 = 7831</li></ul></li></ul></li><li><p><strong>例题：缺页中断处理</strong>：</p><ul><li>给定逻辑地址24600： <ul><li>页号 = 24600 / 页大小 = 24600 / 4096 = 6</li><li>页号6超出页表范围，发生页错误。</li><li>操作系统处理缺页中断，加载所需页到内存，更新页表。</li></ul></li></ul></li></ol><hr><h2 id="信号量机制" tabindex="-1">信号量机制 <a class="header-anchor" href="#信号量机制" aria-label="Permalink to &quot;信号量机制&quot;">​</a></h2><h3 id="考点总结-2" tabindex="-1">考点总结： <a class="header-anchor" href="#考点总结-2" aria-label="Permalink to &quot;考点总结：&quot;">​</a></h3><ol><li><p><strong>信号量的定义和初始化</strong>：</p><ul><li><code>mutex</code>：控制缓冲区的互斥访问，初值为1</li><li><code>empty</code>：记录空缓冲区的数量，初值为N</li><li><code>full</code>：记录满缓冲区的数量，初值为0</li></ul></li><li><p><strong>生产者-消费者问题</strong>：</p><ul><li>生产者：生成产品并放入缓冲区。</li><li>消费者：从缓冲区取出产品并处理。</li></ul></li><li><p><strong>信号量操作</strong>：</p><ul><li><code>wait</code>：检查并等待资源可用。</li><li><code>signal</code>：释放资源并唤醒等待进程。</li></ul></li></ol><h3 id="示例-2" tabindex="-1">示例： <a class="header-anchor" href="#示例-2" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><ol><li><strong>伪代码描述</strong>：<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">semaphore mutex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">semaphore empty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> N;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">semaphore full </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> producer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 生成一个正整数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(empty);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待有空的缓冲区单元</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 进入临界区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将item放入缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 离开临界区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(full);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 增加满的缓冲区单元数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumer_odd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(full);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待有满的缓冲区单元</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 进入临界区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getodd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 从缓冲区中取出一个奇数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        countodd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 统计奇数个数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 离开临界区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(empty);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 增加空的缓冲区单元数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consumer_even</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(full);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 等待有满的缓冲区单元</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 进入临界区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> geteven</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 从缓冲区中取出一个偶数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        counteven</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 统计偶数个数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 离开临界区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(empty);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 增加空的缓冲区单元数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol>`,31)]))}const g=i(p,[["render",t]]);export{E as __pageData,g as default};
