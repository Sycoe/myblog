import{_ as e,c as p,o as i,af as n,j as s,a}from"./chunks/framework.B0E2DVLT.js";const K=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/大三下/网络协议.md","filePath":"posts/大三下/网络协议.md"}'),t={name:"posts/大三下/网络协议.md"};function o(c,l,r,_,d,h){return i(),p("div",null,l[0]||(l[0]=[n(`<p>• 交换Hello消息，对于算法、 交换随机值等协商一致 • 交换必要的密码参数，以便 双方得到统一的premaster secret • 交换证书和相应的密码信息 ，以便进行身份认证 • 产生master secret • 把安全参数提供给SSL记录层 • 检验双方是否已经获得同样的安全参数 阶段1：建立安全功能，包括协议版本，会话标志，密码套件，压缩方法和初始随机数 阶段2：服务器发送证书，密钥交换 ，请求证书。服务器发出问候消息阶段结束信号 阶段3：客户端发送证书，客户发送密钥交换消息，客户端发送证书验证信息 阶段4：改变密码套件并结束握手协议</p><p>下面给出对称型 Needham–Schroeder 公钥中心（KDC）协议的完整流程，包括每一步的消息结构、各方操作和安全意义。</p><hr><h2 id="参与方与符号" tabindex="-1">参与方与符号 <a class="header-anchor" href="#参与方与符号" aria-label="Permalink to &quot;参与方与符号&quot;">​</a></h2><ul><li><p><strong>A</strong>, <strong>B</strong>：要建立安全会话的两个主体</p></li><li><p><strong>KDC</strong>：密钥分发中心（Key Distribution Center）</p></li><li><p>KAK_A，KBK_B：KDC 与 A、B 分别共享的长期对称密钥</p></li><li><p>KsK_s：本次会话的临时对称会话密钥，由 KDC 生成</p></li><li><p>N1,N2N_1, N_2：A、B 各自生成的随机数（Nonce），用以防重放、保证新鲜性</p></li><li><p>IDA,IDBID_A, ID_B：A、B 的身份标识</p></li><li><p>EK[X]E_{K}[X]：用密钥 KK 对消息 XX 做对称加密</p></li></ul><hr><h2 id="协议流程" tabindex="-1">协议流程 <a class="header-anchor" href="#协议流程" aria-label="Permalink to &quot;协议流程&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1) A → KDC：</span></span>
<span class="line"><span>      ID_A ∥ ID_B ∥ N₁</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2) KDC → A：</span></span>
<span class="line"><span>      E_{K_A} [ K_s ∥ ID_B ∥ N₁ ∥ Ticket_{B} ]</span></span>
<span class="line"><span>   其中，Ticket_{B} = E_{K_B}[ K_s ∥ ID_A ]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>3) A → B：</span></span>
<span class="line"><span>      Ticket_{B} ∥ E_{K_s}[ ID_A ∥ N₁&#39; ]</span></span>
<span class="line"><span>   （有的版本用 N₁，有的用新随机 N₁&#39;，此处可统一用 N₁）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>4) B → A：</span></span>
<span class="line"><span>      E_{K_s}[ N₂ ]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>5) A → B：</span></span>
<span class="line"><span>      E_{K_s}[ f(N₂) ]</span></span></code></pre></div><p>下面逐步解析。</p><hr><h3 id="步骤-1-a-向-kdc-请求会话密钥" tabindex="-1">步骤 1：A 向 KDC 请求会话密钥 <a class="header-anchor" href="#步骤-1-a-向-kdc-请求会话密钥" aria-label="Permalink to &quot;步骤 1：A 向 KDC 请求会话密钥&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A → KDC:  ID_A ∥ ID_B ∥ N₁</span></span></code></pre></div><ul><li><p>A 告诉 KDC：</p><ul><li><p>“我是 A”（ID_A）</p></li><li><p>“我想和 B（ID_B）通信”</p></li><li><p>“请给我一个用于本次会话的随机数 N₁，以便后续验证新鲜性”</p></li></ul></li></ul><hr><h3 id="步骤-2-kdc-回复-a" tabindex="-1">步骤 2：KDC 回复 A <a class="header-anchor" href="#步骤-2-kdc-回复-a" aria-label="Permalink to &quot;步骤 2：KDC 回复 A&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>KDC → A:  E_{K_A}[ K_s ∥ ID_B ∥ N₁ ∥ Ticket_{B} ]</span></span></code></pre></div>`,16),s("ul",null,[s("li",null,[s("p",null,[s("strong",null,"K_s"),a("：KDC 为 A 和 B 本次会话专门生成的临时对称密钥")])]),s("li",null,[s("p",null,[s("strong",null,"N₁"),a("：原封不动返回，保证了本次回复的“新鲜性”（防止旧消息重放）")])]),s("li",null,[s("p",null,[s("strong",null,"ID_B"),a("：明确本次密钥是给 A 与 B 使用，防止中间人混淆")])]),s("li",null,[s("p",null,[s("strong",null,"Ticket_{B}"),a("：KDC 用 B 的长期密钥 KBK_B 加密的凭证")]),s("p",null,[a("TicketB=EKB[ Ks∥IDA ] \\text{Ticket}"),s("em",{K_B:""},"{B} = E"),a("[, K_s ∥ ID_A ,]")]),s("p",null,"只有 B 能解，内含会话密钥 KsK_s 和 A 的身份。")])],-1),n('<p>A 用自己与 KDC 共享的 KAK_A 解密，就得到 {Ks,IDB,N1,TicketB}{K_s,ID_B,N_1,Ticket_{B}}，验证 N1N_1 与自己发出的一致、ID_B 无误后，才放心使用 KsK_s 与 B 通信。</p><hr><h3 id="步骤-3-a-将凭证和验证信息转给-b" tabindex="-1">步骤 3：A 将凭证和验证信息转给 B <a class="header-anchor" href="#步骤-3-a-将凭证和验证信息转给-b" aria-label="Permalink to &quot;步骤 3：A 将凭证和验证信息转给 B&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A → B:  Ticket_{B} ∥ E_{K_s}[ ID_A ∥ N₁ ]</span></span></code></pre></div><ul><li><p>A 把 KDC 给的 Ticket_{B}（加密块）直接转发给 B</p></li><li><p>同时再用会话密钥 KsK_s 加密“我是 A”及随机数 N₁，供 B 验证</p></li><li><p>B 解开 Ticket_{B}，取得 {Ks,IDA}{K_s,ID_A}，然后用该 KsK_s 解开第二部分，验证 A 的身份和 N₁。</p></li></ul><hr><h3 id="步骤-4-b-向-a-证明自己也掌握了会话密钥" tabindex="-1">步骤 4：B 向 A 证明自己也掌握了会话密钥 <a class="header-anchor" href="#步骤-4-b-向-a-证明自己也掌握了会话密钥" aria-label="Permalink to &quot;步骤 4：B 向 A 证明自己也掌握了会话密钥&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>B → A:  E_{K_s}[ N₂ ]</span></span></code></pre></div><ul><li><p>B 生成新的随机数 N2N₂，用 KsK_s 加密，发给 A</p></li><li><p>这一消息证明：只有真正拿到 K_s 的 B，才能正确地对 N₂ 加密</p></li></ul><hr><h3 id="步骤-5-a-最后回应-完成身份验证与新鲜性验证" tabindex="-1">步骤 5：A 最后回应，完成身份验证与新鲜性验证 <a class="header-anchor" href="#步骤-5-a-最后回应-完成身份验证与新鲜性验证" aria-label="Permalink to &quot;步骤 5：A 最后回应，完成身份验证与新鲜性验证&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A → B:  E_{K_s}[ f(N₂) ]</span></span></code></pre></div><ul><li><p>f(N2)f(N₂) 可以是对 N2N₂ 的简单变换（如 N2−1N₂ - 1 或哈希），</p></li><li><p>B 解密后检查 f(N2)f(N₂) 是否正确，确认 A 真正拥有 KsK_s。</p></li></ul><hr><h2 id="安全性与性质" tabindex="-1">安全性与性质 <a class="header-anchor" href="#安全性与性质" aria-label="Permalink to &quot;安全性与性质&quot;">​</a></h2><ol><li><p><strong>认证（Authentication）</strong></p><ul><li><p>A 确认消息来自 KDC（因为能解开 EKAE_{K_A}）；</p></li><li><p>B 确认消息来自 KDC（因为能解开 EKBE_{K_B}）；</p></li><li><p>A、B 相互确认对方确实拥有会话密钥 KsK_s。</p></li></ul></li><li><p><strong>新鲜性（Freshness）</strong></p><ul><li>随机数 N1,N2N₁,N₂ 防止重放攻击。</li></ul></li><li><p><strong>机密性（Confidentiality）</strong></p><ul><li><p>会话密钥 KsK_s 只有 A、B、KDC 三方知道；</p></li><li><p>而 A 与 B 之间的后续通信都用 KsK_s 加密。</p></li></ul></li><li><p><strong>可扩展性</strong></p><ul><li>每次会话 KDC 都生成新的 KsK_s，无需 A、B 事先共享大量密钥。</li></ul></li></ol><hr><p>这样，Needham–Schroeder 协议就在 5 步内实现了 A 和 B 在不事先直接共享密钥的情况下，通过可信 KDC 安全地协商出一个对称会话密钥，并完成相互认证。</p>',18)]))}const A=e(t,[["render",o]]);export{K as __pageData,A as default};
