import{_ as t,c as e,o as s,af as r}from"./chunks/framework.B0E2DVLT.js";const u=JSON.parse('{"title":"问答题","description":"","frontmatter":{},"headers":[],"relativePath":"posts/大三下/敲不开的答案.md","filePath":"posts/大三下/敲不开的答案.md"}'),n={name:"posts/大三下/敲不开的答案.md"};function l(a,o,i,d,c,g){return s(),e("div",null,o[0]||(o[0]=[r(`<p>2、</p><h3 id="ret2libc的原理" tabindex="-1"><strong>ret2libc的原理</strong> <a class="header-anchor" href="#ret2libc的原理" aria-label="Permalink to &quot;**ret2libc的原理**&quot;">​</a></h3><ol><li><p><strong>覆盖返回地址</strong>：</p><ul><li>利用缓冲区溢出漏洞，将栈中的<strong>返回地址</strong>覆盖为<strong>库函数的入口地址</strong>。</li></ul></li><li><p><strong>构造参数</strong>：</p><ul><li>在栈中覆盖返回地址之后填充<strong>攻击者设定的参数</strong>，使库函数执行时使用这些参数完成恶意行为。</li></ul></li></ol><h3 id="绕过dep的原因" tabindex="-1"><strong>绕过DEP的原因</strong> <a class="header-anchor" href="#绕过dep的原因" aria-label="Permalink to &quot;**绕过DEP的原因**&quot;">​</a></h3><ul><li>DEP使栈内存<strong>不可执行</strong>，但ret2libc不注入代码，而是重用进程空间中已有的位于可执行的内存区域合法库函数代码。</li><li>攻击仅篡改返回地址和参数，库函数本身是合法且可执行的，符合DEP规则。</li></ul><p>5、</p><h3 id="绕过方式" tabindex="-1"><strong>绕过方式</strong> <a class="header-anchor" href="#绕过方式" aria-label="Permalink to &quot;**绕过方式**&quot;">​</a></h3><p>6、 <strong>1. 文件Fuzz测试</strong></p><ul><li><strong>特点</strong>：使用<strong>基于正常模板变异生成的畸形文件</strong>测试软件解析漏洞，分为<strong>盲测</strong>和<strong>智能测</strong>。 <strong>2. 协议Fuzz测试</strong></li><li><strong>特点</strong>：针对<strong>网络协议</strong>构造畸形命令，探测协议解析漏洞，依赖协议逆向工程。 <strong>3. 组件Fuzz测试</strong></li><li><strong>特点</strong>：提取软件组件并分析其接口，构造测试用例驱动组件运行，监测异常。 <strong>4. Web Fuzz测试</strong></li><li><strong>特点</strong>：针对Web应用输入点注入畸形数据，检测XSS等漏洞，通过Payload变异和盲打技术绕过过滤机制。</li></ul><p>7、 （1）</p><ul><li><code>%s</code>表示<strong>输出字符串</strong>，函数会从栈中取出对应的参数作为<code>char*</code>指针，并打印该地址指向的字符串（直到遇到<code>\\0</code>）。</li><li>**漏洞： <ul><li>若格式字符串由用户控制（如<code>printf(str)</code>，<code>str=&quot;%s&quot;</code>），函数会从栈中<strong>读取一个未指定的地址</strong>作为字符串指针，可能导致<strong>内存数据泄露</strong>。<br> （2）<code>printf(&quot;2024%n&quot;, i)</code>（<code>i</code>为整型变量）</li><li><code>%n</code>表示<strong>将已输出的字符数写入内存</strong>，函数会从栈中取出对应参数作为<code>int*</code>指针，并将字符数（此处为4，因为<code>2024</code>占4字符）写入地址。</li></ul></li><li>**漏洞： <ul><li>若<code>i</code>被错误传递为整型值而非指针，函数会将其视为内存地址，导致<strong>向任意地址写入整数4</strong>。</li></ul></li></ul><p>8、</p><ol><li><strong>反跟踪技术</strong><br> 驻留内存监控系统运行，当用户使用<code>DIR</code>命令查看文件时，自动替换被感染文件的时间、日期、长度等信息，显示为感染前的正常状态。</li><li><strong>避开修改中断向量</strong><br> 直接修改中断服务子程序，避免因修改中断向量触发反病毒软件的监测。</li><li><strong>请求在内存中的合法身份</strong><br> 通过多种手段获得合法内存，从而进驻内存</li><li><strong>维持宿主程序的外部特性</strong><br> 截取中断，控制原文件显示原来的正确内容交给用户，掩盖感染痕迹。</li><li><strong>不使用明显的感染标志</strong><br> 通过一系列相关运算判断文件是否感染，避免被检测到感染标志。</li></ol><h1 id="问答题" tabindex="-1">问答题 <a class="header-anchor" href="#问答题" aria-label="Permalink to &quot;问答题&quot;">​</a></h1><p>（1）ROP 对比传统代码注入的优势</p><ul><li>直接复用程序或库中已有的短指令片段，依赖已有代码，不改写或添加可执行内存，不触发不可执行栈或代码完整性校验。</li><li>通过组合 gadget，可构造任意计算逻辑。且每个 gadget 本身都是合法指令，整个链条<s>看似</s>正常调用返回，常规检测难以捕获。 （2）用两个 gadget 将 <code>%eax</code> 的值写入地址 <code>0x8000000C</code></li><li>Gadget r2：<code>pop %edx; ret</code></li><li>Gadget r1：<code>movl %eax, 8(%edx); ret</code> 构造栈布局（按调用顺序从栈顶向下放）：</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ ... 下一步返回地址 ]  </span></span>
<span class="line"><span>| r2 的地址           | ← ret 调用 gadget r2  </span></span>
<span class="line"><span>| 0x80000004          | ← pop %edx，把 0x80000004 装入 edx  </span></span>
<span class="line"><span>| r1 的地址           | ← ret 调用 gadget r1  </span></span>
<span class="line"><span>| （填充任意或下一步）|</span></span></code></pre></div><p>执行流程：</p><ol><li>执行 <code>pop %edx; ret</code> → edx = 0x80000004</li><li>下一条 <code>ret</code> 跳到 <code>movl %eax, 8(%edx); ret</code> → 将 <code>%eax</code> 写入 <code>0x80000004 + 8 = 0x8000000C</code></li></ol>`,19)]))}const h=t(n,[["render",l]]);export{u as __pageData,h as default};
